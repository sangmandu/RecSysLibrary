Tapestry가 고안된 이유는 감당하기 어려울 정도로 많은 메일들을 받기 때문임. 많은 양의 메일을 다루는 방법에는 여러가지가 있음. 1) 유저가 구독한 메일만 받는 방법. 그치만 깔끔하게 받아지기는 어려운 방법. 2) 유저가 구체적인 필터를 만드는 방법. 이미 몇몇 메일 시스템은 이 방법을 적용중임. Tapestry의 목적은 이러한 필터링 방법을 더 효과적으로 하는데 있음.

컨텐츠 기반 필터링뿐만 아니라 Tapestry는 협업 필터링도 지원함. 협업 필터링은 유저간의 상호작용을 비교하는 방법. 보통 annotations라고 불리는 유저가 재미있다 또는 재미없다 라고한 반응들은 다른 필터에서 이용할 수 있음.

Tapestry는 내가 모든 문서를 볼 시간도 없고 검색은 하고 싶지만 뭐라고 검색해야 할 지 모를 때 Smith, Jones, O'Brien이 응답한 문서라고 추천해줄 수 있음.

협업 필터링의 경우 두 개 이상의 텍스트들(메세지와 이에 대한 답장 또는 문서와 피드백)이 관련있다는 점에서 새롭다. 현재의 필터링 시스템과 달리 Tapestry는 단순히 문서가 도착했을 때 검사하는 게 아니라 반복적으로 전체적인 문서들을 검사함. 언젠가 스미스가 어떤 문서를 읽고 재미있다 평가하면 그 때  나도 

Tapestry는 메일 시스템 그 이상의 역할이 가능함. 또, 단순히 필터링 뿐만 아니라 저장소 역할도 함. 유저는 원하는 문서를 찾으려고 할 때는 키워드로 검색을 할 것임. 이 때, 매우 많은 문서가 검색되므로 키워드를 하나 더 설정하거나 최소 3명이 평가한 문서를 찾는 것이 더 효과적임을 알것임.

### Architecture
Tapestry는 Indexer, Documnet Store, Annotation store, Filterer, Little box, Remailer, Appraiser, Reader/Browser로 구성됨.

* Indexer : 메일이나 뉴스기사같은 외부문서를 가져와 쿼리를 가지고 참고할 수 있도록 인덱싱 하는 역할
* Document Store : 저장소 역할을 하는데, 쿼리가 효율적으로 수행될 수 있도록 함. 데이터 추가만 가능
* Annotation store : anootation 저장소 역할. 데이터 추가만 가능.
* Filterer : 유저의 쿼리랑 매칭되는 문서들을 배치만큼씩 반복적으로 찾음
* Little box : 유저가 관심있는 문서들을 담아둠. 각각의 유저는 이 박스가 있음
* Remailer : 주기적으로 little box에 문서들을 유저한테 보내줌
* Appraiser : 유저의 문서들을 개인화해서 분류해줌. 자동으로 우선순위를 결정하고 분류함
* Reader/Browser : 인터페이스 제공. 필터를 추가, 삭제 수정하거나, 새 문서를 받거나, 보거나 모으거나, 반응을 달 수 있음

대부분의 Tapestry 구조는 협업 필터링을 제공하는 데 목적이 있음. documnets끼리 비교하려면 documnet store가 있어야 하고 유저의 평점과 비교하려면 annotations가 있어야 함.


### Document and Annotation Stores
이상적으로는 Tapestry는 documents를 영구 보관할 것임. annotations은 분리되서 보관되지만 관련 문서와 연결은 되어있음. 한곳에 두면 좋겠지만 그러지 못하는 이유가 있음.
* doc이 저장되고 이후에 anno가 저장되는데 (문서는 append-only만 가능하므로) doc 뒤에 anno를 추가하면 doc의 불변성을 해침
* 복잡한 anno와 간단한 anno가 있는데 복잡한 anno의 경우 붙여놓으면 query로 불러오기 어려운 점이 있음. Annotations 부분에서 또 설명하겠음

### Appraisers
Tapestry 유저는 단순히 관심있음 없음을 필터링하는 것보다 우선순위에 맞게 필터링 하는 것을 원함. 이를 위해서 Appraisers가 있음. 직관적인 작동 방식은 아님. 매 유저마다 appreaise를 작동시키는게 제일 간단한 방법 같지만, 백명의 유저가 많은 쿼리를 많은 doc에다가 매분마다 수행하는 것은 계산적으로 결함이 있는 방법임. 그래서 Tapestry는 다음과 같은 두 단계로 진행함.
1) 일단, 관심있는지 없는지부터 구분을 함. 관심있는 문서는 little box로 이동됨
2) 그래서, little box에 있는 문서만 필터링 함. 그래서 복잡한 appraiser를 지원할 수 있음

### Browsers
Tapestry의 browser는 mail reader랑 기존의 doc browser를 합친 구조임. mail reader가 하던, 새 메일을 little box로 보내고 유저가 이를 관리할 수 있게함. 또, 주기적으로 appraiser를 작동시킴. 기존의 메일 시스템은 메일을 복사해서 가지고 있기 마련인데, Tapestry는 pointer만 가지고 있어서 불변성을 유지함. 유저가 메세지를 지워도 사실 지워진 것은 아니며 언제든 복구할 수 있음. 또, 유저가 문서를 읽었는지 안읽었는지 또는 어떤 폴더에 저장되어 있는지 같은 정보를 저장하는 private filed가 있음. 이는 filter query로는 수정이 불가하고 시스템 쿼리(=ad hoc)로 수정 가능

### TQL, Tapestry Query lANGUAGE
Tapestry는 문서를 구체적인 쿼리로 필터링함. 따라서 이러한 쿼리는 중요한 요소 중 하나임. 제일 괜찮은 방법은 흔히 사용되는 SQL언어를 선택하는 것임. 이를 이용하면 구현에 있어서도 간단해지기 때문에 장점이 있음. 그치만 그렇게 하지 않은 두 가지 이유가 있음
1) 관계형 모델(=SQL)과 Tapestry 모델에는 차이가 있음. Tapestry는 문서의 field set들이 확장성있는 반면 SQL은 고정적임. 그리고, SQL은 sets을 지원하지 않는데 doc files의 경우는 거의 set-value임
2) 유저가 쉽게 ad hoc 쿼리를 사용하게 하고 싶은데 SQL 상용구 쿼리는 어려움
그래서 쿼리를 위해 독자적인 TQL 언어가 고안됨

### Basic Examples
TQL 쿼리는 1차 술어 논리랑 비슷하지만 sets을 지원한다는 점에서 다름. 가장 간단한 쿼리는 =나 <와 같은 기본 연산을 사용하는 것. `m.to = {'Joe', LIKE '%Bi11%'}` 와 같은 쿼리(=m.to 라는 field에 Joe가 들어가거나 Bill이 포함되는 문서)가 가능하며 `EXISTS (ml: ml.sender = 'Joe' AND ml.in-reply-to = {m})` 와 같은 협업 쿼리(=Joe가 답변한 모든 문서 m)가 가능. 또, 다른 유저의 필터도 사용할 수 있음. `m IN Terry.Baseball AND re.words = {'Dodgers'}`. 테리의 베이스볼 쿼리에 포함되면서 m.words가 Dodgers인 문서

### Annotations
지금까지 설명한 TQL은 한번에 결정되는 것이 아니고 전자 문서의 형태를 가진 쿼리 언어를 통해 결정. 그래서 anno를 다루는 것이 직관적이지 않을 수 있음.  이전 섹션에서 말한 것처럼 anno는 doc 데이터와 같이 저장되지 않음. 그렇지만 이것이 별개의 필드로 저장되는 느낌은 아님. 오히려 우선순위 같은 anno를 매우 자연스럽게 표현하는 구조. 예를 들어서 'm.a.priority' 라는 건 doc의 우선순위에 접근하기 위함이며 이 때 a는 annotation의 또다른 네이밍임. 비슷하게 폴더에 접근할 때도 'm.a.folders'로 접근할 수 있음.

협업 필터링에 사용되는 복잡한 anno에 대해서는 깔끔하게 작성하기는 어려움. 만약에 필드를 추가해서 voting 시스템을 구현한다고 해보면 vote라는 anno가 있을건데, 이러한 anno는 자기만의 구성이 있음. voter는 누구고, 뭘 vote 했는지에 관한 부분 등. weiser가 vote한 message를 찾아달란 쿼리가 있다고 하면 m.a.vote는 v.owner=weiser 인 v라는 멤버 변수를 가져야 하고 이러한 방식에서 집합 표기방식을 확장할 필요가 있음.

이 쿼리를 TQL로 표현하면 다음과 같음
```
a.type = 'vote'
AND a.owner = 'weiser'
AND a.msg = m
```

anno에는 doc이랑 연결되기 위한 msg 필드가 항상 있기 때문에 협업 필터링을 지원하는 이러한 쿼리들은 좀 더 간단하게 표현할 수 있음. 이전에 언급한 EXISTS를 이용하면 됨. 이전 쿼리는 EXISTS가 암묵적으로 생략된 것이고 다음과 같이도 쓸 수 있음
```
EXISTS (a: a.type = 'vote'
AND a.owner = 'weiser'
AND a.msg = m) 
```

이러한 표기 방식은 우선순위가 10인 문서 라는 간단한 문장도 다소 복잡하게 표현하게 된다.
```
a.type = 'priority' AND a.value = 10
AND a.msg = m
```

그렇지만 Tapestry가 협업 필터링을 지원하는 것이 목적이므로 이러한 분리형 annotation 방식이 더 적합하다고 판단했음.

### Filter Queries
Tapestry의 중심부는 유저의 필터 쿼리를 수행하는 Filterer가 있음. 주기적으로 실행되는데, 이전에 반환했던 기존의 메시지를 또 보내는 문제점이 있음. 그래서 이를 막는 무언가가 필요함. 또, 주기적인 실행은 예기치 못한 문제점을 발생시킴. 이 주기적인 실행을 언제하냐에 따라서 기존 쿼리를 만족할 수도, 만족하지 않을 수도 있음. 이러한 쿼리는 시스템의 작동방식에 독립적이어야함. 두 명의 유저가 동일한 쿼리를 사용했다면 동일한 결과를 주어야함. 따라서, 시간에 독립적이어야 함.

### Continuous Semantics
Tapestry는 filter query에 continuous semantics라는 개념을 부여했는데, 이는 매 시간시간마다의 결과물이 연속적으로 제공됨을 의미함. 그래서 시스템은 유저에게 어떤 시간에든 결과물을 제공할 수 있음. 여기서 중요한 것은, 실제로 유저에게 보여지는 결과물은 잘 정리되고 시간에 관계없는 결과물이라는 것.

몇 개의 개념을 정의해보자. Q(t)는 시간 t에 실행된 쿼리 Q의 결과물이라고 하자. 근데 만약 continuous semantics와 함께 실행된다면 이 결과물은 단순히 시간 t에 실행된 결과물이 아닌, 시간 t까지 실행된 쿼리 Q의 종합 결과물임. 이러한 결과는 단순히 한 시점에 발생한 결과물과는 질적으로 다르다. 

만약, 유저가 메일을 보냈지만 답장을 받지 못한 메일을 찾고자 하면, "아무도 답장을 하지 않은 메일을 찾아줘" 라고 쿼리를 입력할 것임. 근데 이렇게 되면 모든 메일이 반환될 것임. 왜냐? 해당 시점에서는 어느 메일도 답장을 받지 않았기 때문. 다시 말해, 답장을 받은 메일이 있더라도, 그 메일이 현재 시점에서 답장을 받은 것은 아니기 때문에 그러한 메일 조차 반환이 될 것이라는 것. 그런데 이런 악의적인(?) 수행을 유저가 원한것은 절대로 아닐 것임. 그러면 continous semantics가 문제냐? 그것은 아님. 오히려 유저의 쿼리가 너무 모호했다는 것이 문제. 수행해야 할 일은 지금까지 답변을 받았던 적이 없어서 계속 답장을 기다려야만 하는 메일을 찾아야 하는 것. 그래서 다음의 예시처럼 좀 더 정확한 쿼리가 필요함. "2주 이상 아무도 답장을 하지 않은 문서를 찾아줘" 이러한 예시에서 알 수 있는 것은 몇몇 쿼리들은 한 시점을 기준으로 수행되는 것이 반복적으로 수행되는 것보다 합리적이라는 것.

### Implementation
실제 시스템에서 continous semantics이 적용되려면 쿼리가 매 시간마다 수행되어야 하고 이는 실용적이지는 않음. 이번 장에서는 효율적이고 효과적인 방식으로 c.s 를 적용하는 기술에 대해 소개함.

핵심은 결과물의 수가 줄어들지 않는 단조함수라는 것. 이는 연속적임을 의미하며 그래서 continuous semantics를 적용할 수 있음. 주기적으로 이러한 query with c.s 를 수행할 때는 전체 결과물의 수가 아닌, 각 시점의 결과물의 수에 영향을 미침.

Tapestry는 두 단계로 filter queries with c.s를 수행하는데, 첫째로 query를 단조함수가 되도록 재구성함. 이 재구성된 쿼리는 현재 시점에서 원래 쿼리에 해당하는 모든 문서를 얻거나 또는 과거 시점에 해당하는 모든 문서를 얻음. 만약 r시점에서 얻은 Q(r)과 r 이후의 시점 t에서 얻은 Q(t)가 있으면 Q(t)-Q(r)을 함으로써 c.s를 수행할 수 있음.

일반적으로 Q(t)-Q(r)은 거의 똑같고, 이미 유저에게 제공된 결과물들을 포함하고 있음. 또, Q(t)-Q(r)을 계산하는 것이 매우 비효율적인데, 둘 다 그 크기가 클 뿐더러 대부분의 데이터가 Q(t)-Q(r)을 계산하면서 삭제되기 때문임. 그래서 Tapestry는 두번째 단계를 수행하게 되는데 이를 위해 단조함수 쿼리로 작성된 Q를 증분함수 쿼리 Q^I(r, t)로 재구성하게 됨. 이는 Q(t)-Q(r)을 빠르게 계산할 수 있는 함수임

지금까지를 요약하면, filter query가 입력되면 쿼리를 단조함수 쿼리 Q로 변환함. 그리고 이후에 이 Q를 증분 함수 쿼리 Q^I로 변환함. 필터는 이 증분 쿼리를 반복적으로 실행함. 선택된 문서들을 유저에게 전송하기 위해 계속 쌓아가고, 각각의 쿼리가 발생한 시간을 기록하고, 일정 시간을 대기함. 기록된 시간을 가지고 이 과정을 반복함. 

이것이 Tapestry가 모든 문서를 지우지 않고 저장하는 이유임. 만약 문서가 지워지면 유저 별로 동일한 필터임에도 불과하고 다른 결과를 얻기 때문임. 

### Examples
이번 예시를 통해 쿼리가 변환되는 과정을 익힐 수 있어야 함. 만약 "Joe가 전송한 메세지를 모두 보여줘" 라고 하는 다음과 같은 쿼리가 있다고 하자.

```
m.sender = 'Joe'
```

이 쿼리는 이미 단조함수인데, 시간이 지날 수록 조가 보낸 메세지의 수는 감소하지는 않기 때문. 즉, 시간이 지날 수록 이 수가 증가하거나 같지 적어도 감소하지는 않음. 그러므로 이 쿼리는 매우 쉽게 증분 함수로 변환할 수 있음. 증분함수는 반드시 시점 r와 t 사이에 있는 메세지를 반환함을 기억하자. 이어지는 예시에서는 증분 함수 쿼리가 시점 t와 r 사이에 있는 메세지를 고려하는 것을 보여줌

```
m.sender = 'Joe' AND
(r < m.ts AND m.ts - t)
```

여기서 ts는 timestamp를 의미하며 document store에 도착한 시간임. 좀 더 복잡한 예시를 살펴보자. "보고된 지 2주가 넘었지만 답변이 달리지 않은 버그를 보여줘" 라는 쿼리는 다음과 같이 작성될 수 있다

```
m.to = 'BugReports' AND
  m.ts + [2 weeks] < now() AND
NOT EXISTS (mreply:
  mreply.in_reply_to = {m})
```

이 쿼리는 단조함수는 아닌데, 만약 답장이 달렸으면 전체 수는 감소할 수도 있기 때문. 따라서 Tapestry는 이를 다음과 같은 과정으로 단조함수로 바꾸게 된다.

```
m.to = 'BugReports' AND 
Set r = -oo
FOREVER DO
  set t := current time
  Execute query Q^I('c, t)
  Return result to user
  set r := t
  Sleep for some period of time
ENDLOOP 

  m.ts + [2 weeks] < now() AND
NOT EXISTS (mreply:
  mreply.in_.reply_to = {m}
  AND mreply.ts < m.ts + [2 weeks])
```
이 단조함수는 원래의 쿼리랑은 다소 다른 의미를 가지지만 c.s만은 동일하다. 구체적으로 "2주안에 답변되지 않은 버그 레포트를 보여달라" 라는 의미만은 동일하다.

이 증분 함수 버전은 시점 r과 t사이에 있는 2주 이상된 모든 메세지를 확인한다. 

```
m.to = 'BugReports' AND
  m.ts + [2 weeks] < now() AND
  (~" < m.ts + [2 weeks] AND
  m.ts + [2 weeks] -< t) AND
NOT EXISTS (mreply:
  mreply.in__reply_to = {m} AND
  mreply.ts < m.ts + [2 weeks])
```

실제로 현재 시각 now()와 t는 동일한 의미로 사용되기 때문에 이러한 쿼리 "AND m.ts + [2 weeks] < now()"는 없애도 된다.

이해하기가 힘든 부분. 아무리 읽어도 잘 모르겠음. 다시 정리하면, 유저에게 매 시간마다 결과물을 보여주려고 Continous Semantics을 사용함. 근데, 이것이 시간에 독립적이어야함. 어떤 시간에 쿼리를 작성하든 동일한 쿼리에 대해서는 동일한 결과를 보여줘야 한다는 뜻. 그런데, 실제로는 그럴 수가 없음. 그렇다 보니 이러한 결과를 동일하게 보여주기 위해 현재 시점 t에 대해서 Q(t)가 아닌, 과거 시점 r에서 부터 현재 시점 t까지의 결과 Q(t)-Q(r)을 보여주려고 함. 이 경우는 시간독립적인 결과물이 나오는 듯.

그래서 기존 쿼리를 단조함수로 만들려고 함. 이 이유는 무엇이냐면, r부터 t까지의 결과물을 얻는 과정을 매 시간마다 수행하게 되면 아무래도 과부화가 생기기 마련임. 굳이 동일한 결과를 계속 구하는 꼴이 되버림. 그런데 이것이 단조함수로 구성이 되면 현재 시점만 구해도 되고, 이는 전체 사이즈가 아닌 현재 시점의 사이즈에만 영향을 주게됨. 아마, 단조함수 전에 쿼리는 전체를 구하는 쿼리였다면 단조함수로 만든 쿼리는 각 시점에서만 구할 수 있는 쿼리로 분리되게 된 것 같음. 예를 들어, 어떤 함수 F에 대해서 시점 1부터 5까지의 값을 구하는 함수 F가 있다면 이를, 특정 x 시점에서의 값을 구하는 함수 F(x)로 바꾼 함수.

그런데 단조함수로 만들고 보니 이 Q(t)-Q(r)이 비효율적임. 왜냐? 일단 Q(t)와 Q(r)이 너무 크다보니까 구하기도 오래걸리기 때문. 그리고 열심히 구해놓았는데 두 값이 비슷하기 때문에 Q(t)-Q(r)을 구해보니 구한 데이터의 대부분이 또 사라지기 때문임. 그래서 이 과정을 효율적으로 계산하기 위해 단조함수 Q를 증분함수 Q^I(r, t)로 변환시키는 방법론을 택함.

그러면 과거 시점 r에서 부터 현재 시점 t까지의 모든 시점의 결과를 구할 필요가 없음. 무슨 말이냐면 1시부터 5시까지 매 시간마다 숨을 쉰 횟수를 구하려면 1시, 2시, 3시, 4시, 5시를 모두 구해야하는데, 이 함수가 단조함수라면 단순히 5시까지 숨쉰 횟수 - 1시까지 숨쉰 횟수를 구함으로써 사이 값을 구하지 않아도 되는 장점이 생김. 또한 이러한 개념이 c.s와 매칭됨. 마치 누적합 그래프에서 현재 시점의 값을 구하는 과정과 동일.

### The Current System






